//! Declares the [`Signal`] trait and implements it for simple types.

use std::marker::PhantomData;

use crate::sample::*;
use crate::Map;

/// A trait for a stream of data, generated every frame.
///
/// This data can either be audio data, or envelope data.
pub trait Signal {
    /// The type of sample generated by the signal.
    type Sample: Sample;

    /// Gets the next sample from the signal.
    fn get(&self) -> Self::Sample;

    /// Advances the state of the signal to the next sample.
    fn advance(&mut self);

    /// Resets the stream to its initial state.
    fn retrigger(&mut self);

    /// Gets the next sample and advances the state of the signal.
    fn next(&mut self) -> Self::Sample {
        let res = self.get();
        self.advance();
        res
    }
}

/// Represents a signal that can be stopped.
pub trait StopSignal: Signal {
    /// Releases a note.
    fn stop(&mut self);

    /// Returns whether the signal has stopped producing any sound altogether.
    fn is_done(&self) -> bool;
}

/// A trailing signal. It can be stopped, but won't actually stop producing an
/// output.
pub struct Trailing<S: Signal> {
    /// The inner signal.
    pub sgn: S,
}

impl<S: Signal> Trailing<S> {
    pub fn new(sgn: S) -> Self {
        Self { sgn }
    }
}

impl<S: Signal> Signal for Trailing<S> {
    type Sample = S::Sample;

    fn get(&self) -> Self::Sample {
        self.sgn.get()
    }

    fn advance(&mut self) {
        self.sgn.advance();
    }

    fn retrigger(&mut self) {
        self.sgn.retrigger();
    }
}

impl<S: Signal> StopSignal for Trailing<S> {
    fn stop(&mut self) {}

    fn is_done(&self) -> bool {
        false
    }
}

/// Maps a signal to another via a specified map.
#[derive(Clone, Copy, Debug)]
pub struct MapSgn<S: Signal, Y: Sample, F: Map<S::Sample, Y>> {
    /// The signal being mapped.
    pub sgn: S,

    /// The map being applied.
    pub map: F,

    /// Dummy variable.
    phantom: PhantomData<Y>,
}

impl<S: Signal, Y: Sample, F: Map<S::Sample, Y>> MapSgn<S, Y, F> {
    /// Initializes a generic [`MapSgn`].
    ///
    /// There are many type aliases for specific subtypes of [`MapSgn`], and
    /// these will often provide more convenient instantiations via `new`.
    pub fn new_generic(sgn: S, map: F) -> Self {
        Self {
            sgn,
            map,
            phantom: PhantomData,
        }
    }
}

impl<S: Signal, Y: Sample, F: Map<S::Sample, Y>> Signal for MapSgn<S, Y, F> {
    type Sample = Y;

    fn get(&self) -> Y {
        self.map.eval(self.sgn.get())
    }

    fn advance(&mut self) {
        self.sgn.advance()
    }

    fn retrigger(&mut self) {
        self.sgn.retrigger();
    }
}

impl<S: StopSignal, Y: Sample, F: Map<S::Sample, Y>> StopSignal for MapSgn<S, Y, F> {
    fn stop(&mut self) {
        self.sgn.stop();
    }

    fn is_done(&self) -> bool {
        self.sgn.is_done()
    }
}

/// A map which converts an envelope into mono audio.
#[derive(Clone, Copy, Debug, Default)]
pub struct EnvToMono;

impl Map<Env, Mono> for EnvToMono {
    fn eval(&self, x: Env) -> Mono {
        x.into()
    }
}

/// Plays an envelope as a [`Mono`] audio file.
///
/// For very low-frequency envelopes, this might lead to undesirable sounds.
pub type EnvGen<S> = MapSgn<S, Mono, EnvToMono>;

impl<S: Signal<Sample = Env>> EnvGen<S> {
    /// Initializes a new [`EnvGen`].
    pub fn new_env(sgn: S) -> Self {
        Self::new_generic(sgn, EnvToMono)
    }
}
